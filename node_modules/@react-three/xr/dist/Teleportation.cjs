"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const THREE = require("three");
const React = require("react");
const fiber = require("@react-three/fiber");
const Interactions = require("./Interactions.cjs");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const THREE__namespace = /* @__PURE__ */ _interopNamespace(THREE);
const React__namespace = /* @__PURE__ */ _interopNamespace(React);
const _q = /* @__PURE__ */ new THREE__namespace.Quaternion();
function useTeleportation() {
  const frame = React__namespace.useRef();
  const baseReferenceSpace = React__namespace.useRef(null);
  const teleportReferenceSpace = React__namespace.useRef(null);
  fiber.useFrame((state, _, xrFrame) => {
    var _a;
    frame.current = xrFrame;
    const referenceSpace = state.gl.xr.getReferenceSpace();
    (_a = baseReferenceSpace.current) != null ? _a : baseReferenceSpace.current = referenceSpace;
    const teleportOffset = teleportReferenceSpace.current;
    if (teleportOffset && referenceSpace !== teleportOffset) {
      state.gl.xr.setReferenceSpace(teleportOffset);
    }
  });
  return React__namespace.useCallback((target) => {
    var _a;
    const base = baseReferenceSpace.current;
    if (base) {
      const [x, y, z] = Array.from(target);
      const offsetFromBase = { x: -x, y: -y, z: -z };
      const pose = (_a = frame.current) == null ? void 0 : _a.getViewerPose(base);
      if (pose) {
        offsetFromBase.x += pose.transform.position.x;
        offsetFromBase.z += pose.transform.position.z;
      }
      const teleportOffset = new XRRigidTransform(offsetFromBase, _q);
      teleportReferenceSpace.current = base.getOffsetReferenceSpace(teleportOffset);
    }
  }, []);
}
const TeleportationPlane = React__namespace.forwardRef(function TeleportationPlane2({ leftHand = false, rightHand = false, maxDistance = 10, size = 0.25, ...props }, ref) {
  const teleport = useTeleportation();
  const marker = React__namespace.useRef(null);
  const intersection = React__namespace.useRef();
  const camera = fiber.useThree((state) => state.camera);
  const isInteractive = React__namespace.useCallback(
    (e) => {
      var _a;
      const handedness = (_a = e.target.inputSource) == null ? void 0 : _a.handedness;
      return !!((handedness !== "left" || leftHand) && (handedness !== "right" || rightHand));
    },
    [leftHand, rightHand]
  );
  return /* @__PURE__ */ React__namespace.createElement("group", {
    ref,
    ...props
  }, /* @__PURE__ */ React__namespace.createElement("mesh", {
    ref: marker,
    visible: false,
    "rotation-x": -Math.PI / 2
  }, /* @__PURE__ */ React__namespace.createElement("circleGeometry", {
    args: [size, 32]
  }), /* @__PURE__ */ React__namespace.createElement("meshBasicMaterial", {
    color: "white"
  })), /* @__PURE__ */ React__namespace.createElement(Interactions.Interactive, {
    onMove: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
      intersection.current = e.intersection.point;
      marker.current.position.copy(intersection.current);
    },
    onHover: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
    },
    onBlur: (e) => {
      if (!isInteractive(e))
        return;
      marker.current.visible = false;
    },
    onSelectStart: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1.1);
    },
    onSelectEnd: (e) => {
      if (!isInteractive(e) || !intersection.current)
        return;
      marker.current.visible = true;
      marker.current.scale.setScalar(1);
      const distanceFromCamera = intersection.current.distanceTo(camera.position);
      if (distanceFromCamera <= maxDistance) {
        teleport(intersection.current);
      }
    }
  }, /* @__PURE__ */ React__namespace.createElement("mesh", {
    "rotation-x": -Math.PI / 2,
    visible: false,
    scale: 1e3
  }, /* @__PURE__ */ React__namespace.createElement("planeGeometry", null))));
});
exports.TeleportationPlane = TeleportationPlane;
exports.useTeleportation = useTeleportation;
//# sourceMappingURL=Teleportation.cjs.map
