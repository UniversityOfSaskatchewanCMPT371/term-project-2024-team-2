import { GLTFLoader, fetchProfile, MotionController } from "three-stdlib";
const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
const DEFAULT_PROFILE = "generic-trigger";
class XRControllerModelFactory {
  constructor(gltfLoader = null, path = DEFAULT_PROFILES_PATH) {
    this.gltfLoader = gltfLoader != null ? gltfLoader : new GLTFLoader();
    this.path = path;
    this._assetCache = {};
  }
  initializeControllerModel(controllerModel, xrInputSource) {
    if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad) {
      return Promise.resolve();
    }
    return fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {
      if (!assetPath) {
        throw new Error("no asset path");
      }
      const motionController = new MotionController(xrInputSource, profile, assetPath);
      controllerModel.connectMotionController(motionController);
      const assetUrl = motionController.assetUrl;
      const cachedAsset = this._assetCache[assetUrl];
      if (cachedAsset) {
        const scene = cachedAsset.scene.clone();
        controllerModel.connectModel(scene);
      } else {
        if (!this.gltfLoader) {
          throw new Error("GLTFLoader not set.");
        }
        this.gltfLoader.setPath("");
        this.gltfLoader.load(
          assetUrl,
          (asset) => {
            if (!controllerModel.motionController) {
              console.warn("motionController gone while gltf load, bailing...");
              return;
            }
            this._assetCache[assetUrl] = asset;
            const scene = asset.scene.clone();
            controllerModel.connectModel(scene);
          },
          void 0,
          () => {
            throw new Error(`Asset ${assetUrl} missing or malformed.`);
          }
        );
      }
    }).catch((err) => {
      console.warn(err);
    });
  }
}
export {
  XRControllerModelFactory
};
//# sourceMappingURL=XRControllerModelFactory.js.map
