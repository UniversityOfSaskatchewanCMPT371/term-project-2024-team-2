import * as THREE from "three";
import * as React from "react";
import { useThree, useFrame } from "@react-three/fiber";
import { Interactive } from "./Interactions.js";
const _q = /* @__PURE__ */ new THREE.Quaternion();
function useTeleportation() {
  const frame = React.useRef();
  const baseReferenceSpace = React.useRef(null);
  const teleportReferenceSpace = React.useRef(null);
  useFrame((state, _, xrFrame) => {
    var _a;
    frame.current = xrFrame;
    const referenceSpace = state.gl.xr.getReferenceSpace();
    (_a = baseReferenceSpace.current) != null ? _a : baseReferenceSpace.current = referenceSpace;
    const teleportOffset = teleportReferenceSpace.current;
    if (teleportOffset && referenceSpace !== teleportOffset) {
      state.gl.xr.setReferenceSpace(teleportOffset);
    }
  });
  return React.useCallback((target) => {
    var _a;
    const base = baseReferenceSpace.current;
    if (base) {
      const [x, y, z] = Array.from(target);
      const offsetFromBase = { x: -x, y: -y, z: -z };
      const pose = (_a = frame.current) == null ? void 0 : _a.getViewerPose(base);
      if (pose) {
        offsetFromBase.x += pose.transform.position.x;
        offsetFromBase.z += pose.transform.position.z;
      }
      const teleportOffset = new XRRigidTransform(offsetFromBase, _q);
      teleportReferenceSpace.current = base.getOffsetReferenceSpace(teleportOffset);
    }
  }, []);
}
const TeleportationPlane = React.forwardRef(function TeleportationPlane2({ leftHand = false, rightHand = false, maxDistance = 10, size = 0.25, ...props }, ref) {
  const teleport = useTeleportation();
  const marker = React.useRef(null);
  const intersection = React.useRef();
  const camera = useThree((state) => state.camera);
  const isInteractive = React.useCallback(
    (e) => {
      var _a;
      const handedness = (_a = e.target.inputSource) == null ? void 0 : _a.handedness;
      return !!((handedness !== "left" || leftHand) && (handedness !== "right" || rightHand));
    },
    [leftHand, rightHand]
  );
  return /* @__PURE__ */ React.createElement("group", {
    ref,
    ...props
  }, /* @__PURE__ */ React.createElement("mesh", {
    ref: marker,
    visible: false,
    "rotation-x": -Math.PI / 2
  }, /* @__PURE__ */ React.createElement("circleGeometry", {
    args: [size, 32]
  }), /* @__PURE__ */ React.createElement("meshBasicMaterial", {
    color: "white"
  })), /* @__PURE__ */ React.createElement(Interactive, {
    onMove: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
      intersection.current = e.intersection.point;
      marker.current.position.copy(intersection.current);
    },
    onHover: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
    },
    onBlur: (e) => {
      if (!isInteractive(e))
        return;
      marker.current.visible = false;
    },
    onSelectStart: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1.1);
    },
    onSelectEnd: (e) => {
      if (!isInteractive(e) || !intersection.current)
        return;
      marker.current.visible = true;
      marker.current.scale.setScalar(1);
      const distanceFromCamera = intersection.current.distanceTo(camera.position);
      if (distanceFromCamera <= maxDistance) {
        teleport(intersection.current);
      }
    }
  }, /* @__PURE__ */ React.createElement("mesh", {
    "rotation-x": -Math.PI / 2,
    visible: false,
    scale: 1e3
  }, /* @__PURE__ */ React.createElement("planeGeometry", null))));
});
export {
  TeleportationPlane,
  useTeleportation
};
//# sourceMappingURL=Teleportation.js.map
