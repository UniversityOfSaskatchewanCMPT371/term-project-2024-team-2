"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const THREE = require("three");
const XRHandMeshModel = require("./XRHandMeshModel.cjs");
const TOUCH_RADIUS = 0.01;
const POINTING_JOINT = "index-finger-tip";
class OculusHandModel extends THREE.Object3D {
  constructor(controller, leftModelPath, rightModelPath) {
    super();
    this._onConnected = (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand && !this.motionController) {
        this.xrInputSource = xrInputSource;
        this.motionController = new XRHandMeshModel.XRHandMeshModel(
          this,
          this.controller,
          void 0,
          xrInputSource.handedness,
          xrInputSource.handedness === "left" ? this.leftModelPath : this.rightModelPath
        );
      }
    };
    this._onDisconnected = () => {
      var _a;
      if (!((_a = this.xrInputSource) == null ? void 0 : _a.hand)) {
        return;
      }
      this.motionControllerCleanup();
    };
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.leftModelPath = leftModelPath;
    this.rightModelPath = rightModelPath;
    this.mesh = null;
    this.xrInputSource = null;
    controller.addEventListener("connected", this._onConnected);
    controller.addEventListener("disconnected", this._onDisconnected);
  }
  motionControllerCleanup() {
    var _a;
    this.clear();
    (_a = this.motionController) == null ? void 0 : _a.dispose();
    this.motionController = null;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }
  getPointerPosition() {
    const indexFingerTip = this.controller.joints[POINTING_JOINT];
    if (indexFingerTip) {
      return indexFingerTip.position;
    } else {
      return null;
    }
  }
  intersectBoxObject(boxObject) {
    const pointerPosition = this.getPointerPosition();
    if (pointerPosition) {
      const indexSphere = new THREE.Sphere(pointerPosition, TOUCH_RADIUS);
      const box = new THREE.Box3().setFromObject(boxObject);
      return indexSphere.intersectsBox(box);
    } else {
      return false;
    }
  }
  checkButton(button) {
    if (this.intersectBoxObject(button)) {
      button.onPress();
    } else {
      button.onClear();
    }
    if (button.isPressed()) {
      button.whilePressed();
    }
  }
  dispose() {
    this.motionControllerCleanup();
    this.controller.removeEventListener("connected", this._onConnected);
    this.controller.removeEventListener("disconnected", this._onDisconnected);
  }
}
exports.OculusHandModel = OculusHandModel;
//# sourceMappingURL=OculusHandModel.cjs.map
