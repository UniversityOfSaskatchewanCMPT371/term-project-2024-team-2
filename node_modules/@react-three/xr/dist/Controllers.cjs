"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const React = require("react");
const THREE = require("three");
const fiber = require("@react-three/fiber");
const XR = require("./XR.cjs");
const XRControllerModelFactory = require("./XRControllerModelFactory.cjs");
const XRControllerModel = require("./XRControllerModel.cjs");
const utils = require("./utils.cjs");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespace(React);
const THREE__namespace = /* @__PURE__ */ _interopNamespace(THREE);
const Ray = React__namespace.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = XR.useXR((state) => state.hoverState);
  const ray = React__namespace.useRef(null);
  const rayGeometry = React__namespace.useMemo(
    () => new THREE__namespace.BufferGeometry().setFromPoints([new THREE__namespace.Vector3(0, 0, 0), new THREE__namespace.Vector3(0, 0, -1)]),
    []
  );
  React__namespace.useImperativeHandle(forwardedRef, () => ray.current);
  fiber.useFrame(() => {
    if (!target.inputSource) {
      return;
    }
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return /* @__PURE__ */ React__namespace.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
const modelFactory = new XRControllerModelFactory.XRControllerModelFactory();
const ControllerModel = ({
  target,
  envMap,
  envMapIntensity
}) => {
  const xrControllerModelRef = React__namespace.useRef(null);
  const setEnvironmentMapRef = utils.useCallbackRef((xrControllerModel) => {
    if (envMap == null)
      return;
    xrControllerModel.setEnvironmentMap(envMap);
  });
  const clearEnvironmentMapRef = utils.useCallbackRef((xrControllerModel) => xrControllerModel.setEnvironmentMap(null));
  const setEnvironmentMapIntensityRef = utils.useCallbackRef((xrControllerModel) => {
    if (envMapIntensity == null)
      return;
    xrControllerModel.setEnvironmentMapIntensity(envMapIntensity);
  });
  const handleControllerModel = React__namespace.useCallback(
    (xrControllerModel) => {
      var _a, _b, _c;
      xrControllerModelRef.current = xrControllerModel;
      if (xrControllerModel) {
        target.xrControllerModel = xrControllerModel;
        if ((_a = target.inputSource) == null ? void 0 : _a.hand) {
          return;
        }
        setEnvironmentMapRef.current(xrControllerModel);
        setEnvironmentMapIntensityRef.current(xrControllerModel);
        if (target.inputSource) {
          modelFactory.initializeControllerModel(xrControllerModel, target.inputSource);
        } else {
          console.warn("no input source on XRController when handleControllerModel");
        }
      } else {
        if ((_b = target.inputSource) == null ? void 0 : _b.hand) {
          return;
        }
        (_c = target.xrControllerModel) == null ? void 0 : _c.disconnect();
        target.xrControllerModel = null;
      }
    },
    [target, setEnvironmentMapIntensityRef, setEnvironmentMapRef]
  );
  React__namespace.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      if (envMap) {
        setEnvironmentMapRef.current(xrControllerModelRef.current);
      } else {
        clearEnvironmentMapRef.current(xrControllerModelRef.current);
      }
    }
  }, [envMap, setEnvironmentMapRef, clearEnvironmentMapRef]);
  React__namespace.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      setEnvironmentMapIntensityRef.current(xrControllerModelRef.current);
    }
  }, [envMapIntensity, setEnvironmentMapIntensityRef]);
  return /* @__PURE__ */ React__namespace.createElement("xRControllerModel", {
    ref: handleControllerModel
  });
};
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false, envMap, envMapIntensity }) {
  const controllers = XR.useXR((state) => state.controllers);
  const isHandTracking = XR.useXR((state) => state.isHandTracking);
  const rayMaterialProps = React__namespace.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React__namespace.useMemo(() => fiber.extend({ XRControllerModel: XRControllerModel.XRControllerModel }), []);
  return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, controllers.map((target, i) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
    key: i
  }, fiber.createPortal(/* @__PURE__ */ React__namespace.createElement(ControllerModel, {
    target,
    envMap,
    envMapIntensity
  }), target.grip), fiber.createPortal(
    /* @__PURE__ */ React__namespace.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}
exports.Controllers = Controllers;
exports.Ray = Ray;
//# sourceMappingURL=Controllers.cjs.map
