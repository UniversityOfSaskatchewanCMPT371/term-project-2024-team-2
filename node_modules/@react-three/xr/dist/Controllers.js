import * as React from "react";
import * as THREE from "three";
import { useFrame, extend, createPortal } from "@react-three/fiber";
import { useXR } from "./XR.js";
import { XRControllerModelFactory } from "./XRControllerModelFactory.js";
import { XRControllerModel } from "./XRControllerModel.js";
import { useCallbackRef } from "./utils.js";
const Ray = React.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState);
  const ray = React.useRef(null);
  const rayGeometry = React.useMemo(
    () => new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
    []
  );
  React.useImperativeHandle(forwardedRef, () => ray.current);
  useFrame(() => {
    if (!target.inputSource) {
      return;
    }
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return /* @__PURE__ */ React.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
const modelFactory = new XRControllerModelFactory();
const ControllerModel = ({
  target,
  envMap,
  envMapIntensity
}) => {
  const xrControllerModelRef = React.useRef(null);
  const setEnvironmentMapRef = useCallbackRef((xrControllerModel) => {
    if (envMap == null)
      return;
    xrControllerModel.setEnvironmentMap(envMap);
  });
  const clearEnvironmentMapRef = useCallbackRef((xrControllerModel) => xrControllerModel.setEnvironmentMap(null));
  const setEnvironmentMapIntensityRef = useCallbackRef((xrControllerModel) => {
    if (envMapIntensity == null)
      return;
    xrControllerModel.setEnvironmentMapIntensity(envMapIntensity);
  });
  const handleControllerModel = React.useCallback(
    (xrControllerModel) => {
      var _a, _b, _c;
      xrControllerModelRef.current = xrControllerModel;
      if (xrControllerModel) {
        target.xrControllerModel = xrControllerModel;
        if ((_a = target.inputSource) == null ? void 0 : _a.hand) {
          return;
        }
        setEnvironmentMapRef.current(xrControllerModel);
        setEnvironmentMapIntensityRef.current(xrControllerModel);
        if (target.inputSource) {
          modelFactory.initializeControllerModel(xrControllerModel, target.inputSource);
        } else {
          console.warn("no input source on XRController when handleControllerModel");
        }
      } else {
        if ((_b = target.inputSource) == null ? void 0 : _b.hand) {
          return;
        }
        (_c = target.xrControllerModel) == null ? void 0 : _c.disconnect();
        target.xrControllerModel = null;
      }
    },
    [target, setEnvironmentMapIntensityRef, setEnvironmentMapRef]
  );
  React.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      if (envMap) {
        setEnvironmentMapRef.current(xrControllerModelRef.current);
      } else {
        clearEnvironmentMapRef.current(xrControllerModelRef.current);
      }
    }
  }, [envMap, setEnvironmentMapRef, clearEnvironmentMapRef]);
  React.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      setEnvironmentMapIntensityRef.current(xrControllerModelRef.current);
    }
  }, [envMapIntensity, setEnvironmentMapIntensityRef]);
  return /* @__PURE__ */ React.createElement("xRControllerModel", {
    ref: handleControllerModel
  });
};
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false, envMap, envMapIntensity }) {
  const controllers = useXR((state) => state.controllers);
  const isHandTracking = useXR((state) => state.isHandTracking);
  const rayMaterialProps = React.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React.useMemo(() => extend({ XRControllerModel }), []);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, controllers.map((target, i) => /* @__PURE__ */ React.createElement(React.Fragment, {
    key: i
  }, createPortal(/* @__PURE__ */ React.createElement(ControllerModel, {
    target,
    envMap,
    envMapIntensity
  }), target.grip), createPortal(
    /* @__PURE__ */ React.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}
export {
  Controllers,
  Ray
};
//# sourceMappingURL=Controllers.js.map
