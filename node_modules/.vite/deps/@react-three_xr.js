import {
  GLTFLoader,
  MotionController,
  MotionControllerConstants,
  fetchProfile
} from "./chunk-SUPWPVTA.js";
import {
  Box3,
  BufferGeometry,
  Group,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  Quaternion,
  Sphere,
  SphereGeometry,
  Vector3,
  create,
  createPortal,
  extend,
  useFrame,
  useThree
} from "./chunk-A2TR5XD2.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/@react-three/xr/dist/Controllers.js
var React5 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XR.js
var React4 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XRController.js
var XRController = class extends Group {
  constructor(index, gl) {
    super();
    this.inputSource = null;
    this.xrControllerModel = null;
    this.index = index;
    this.controller = gl.xr.getController(index);
    this.grip = gl.xr.getControllerGrip(index);
    this.hand = gl.xr.getHand(index);
    this.grip.userData.name = "grip";
    this.controller.userData.name = "controller";
    this.hand.userData.name = "hand";
    this.visible = false;
    this.add(this.controller, this.grip, this.hand);
    this._onConnected = this._onConnected.bind(this);
    this._onDisconnected = this._onDisconnected.bind(this);
    this.controller.addEventListener("connected", this._onConnected);
    this.controller.addEventListener("disconnected", this._onDisconnected);
  }
  _onConnected(event) {
    if (event.fake)
      return;
    if (!event.data)
      return;
    this.visible = true;
    this.inputSource = event.data;
    this.dispatchEvent(event);
  }
  _onDisconnected(event) {
    if (event.fake)
      return;
    this.visible = false;
    this.inputSource = null;
    this.dispatchEvent(event);
  }
  dispose() {
    this.controller.removeEventListener("connected", this._onConnected);
    this.controller.removeEventListener("disconnected", this._onDisconnected);
  }
};

// node_modules/@react-three/xr/dist/Interactions.js
var React2 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/utils.js
var React = __toESM(require_react(), 1);
var _a;
var _b;
var uniq = (arr) => Array.from(new Set(arr));
var useIsomorphicLayoutEffect = typeof window !== "undefined" && (((_a = window.document) == null ? void 0 : _a.createElement) || ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative") ? React.useLayoutEffect : React.useEffect;
function useCallbackRef(fn) {
  const ref = React.useRef(fn);
  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);
  return ref;
}

// node_modules/@react-three/xr/dist/XREvents.js
function useXREvent(event, handler, { handedness } = {}) {
  const handlerRef = useCallbackRef(handler);
  const controllers = useXR((state) => state.controllers);
  useIsomorphicLayoutEffect(() => {
    const listeners = controllers.map((target) => {
      if (handedness && target.inputSource && target.inputSource.handedness !== handedness)
        return;
      const listener = (nativeEvent) => handlerRef.current({ nativeEvent, target });
      target.controller.addEventListener(event, listener);
      return () => target.controller.removeEventListener(event, listener);
    });
    return () => listeners.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  }, [controllers, handedness, event]);
}

// node_modules/@react-three/xr/dist/Interactions.js
var tempMatrix = new Matrix4();
function InteractionManager({ children }) {
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const raycaster = useThree((state) => state.raycaster);
  const controllers = useXR((state) => state.controllers);
  const interactions = useXR((state) => state.interactions);
  const hoverState = useXR((state) => state.hoverState);
  const hasInteraction = useXR((state) => state.hasInteraction);
  const getInteraction = useXR((state) => state.getInteraction);
  const intersect = React2.useCallback(
    (controller) => {
      const objects = Array.from(interactions.keys());
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(objects, true);
    },
    [interactions, raycaster]
  );
  useFrame(() => {
    var _a2;
    if (interactions.size === 0)
      return;
    for (const target of controllers) {
      if (!((_a2 = target.inputSource) == null ? void 0 : _a2.handedness)) {
        return;
      }
      const hovering = hoverState[target.inputSource.handedness];
      const hits = /* @__PURE__ */ new Set();
      let intersections = intersect(target.controller);
      if (events.filter) {
        intersections = events.filter(intersections, get());
      } else {
        const hit = intersections.find((i) => i == null ? void 0 : i.object);
        if (hit)
          intersections = [hit];
      }
      for (const intersection of intersections) {
        let eventObject = intersection.object;
        while (eventObject) {
          if (hasInteraction(eventObject, "onHover") && !hovering.has(eventObject)) {
            const handlers = getInteraction(eventObject, "onHover");
            for (const handler of handlers) {
              handler({ target, intersection, intersections });
            }
          }
          const moveHandlers = getInteraction(eventObject, "onMove");
          moveHandlers == null ? void 0 : moveHandlers.forEach((handler) => handler({ target, intersection, intersections }));
          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }
      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          hovering.delete(eventObject);
          const handlers = getInteraction(eventObject, "onBlur");
          if (!handlers)
            continue;
          for (const handler of handlers) {
            handler({ target, intersections });
          }
        }
      }
    }
  });
  const triggerEvent = React2.useCallback(
    (interaction) => (e) => {
      var _a2;
      if (!((_a2 = e.target.inputSource) == null ? void 0 : _a2.handedness)) {
        return;
      }
      const hovering = hoverState[e.target.inputSource.handedness];
      const intersections = Array.from(new Set(hovering.values()));
      interactions.forEach((handlers, object) => {
        var _a22, _b2, _c;
        if (hovering.has(object)) {
          if (!handlers[interaction])
            return;
          for (const handler of handlers[interaction]) {
            (_a22 = handler.current) == null ? void 0 : _a22.call(handler, { target: e.target, intersection: hovering.get(object), intersections });
          }
        } else {
          if (interaction === "onSelect" && handlers["onSelectMissed"]) {
            for (const handler of handlers["onSelectMissed"]) {
              (_b2 = handler.current) == null ? void 0 : _b2.call(handler, { target: e.target, intersections });
            }
          } else if (interaction === "onSqueeze" && handlers["onSqueezeMissed"]) {
            for (const handler of handlers["onSqueezeMissed"]) {
              (_c = handler.current) == null ? void 0 : _c.call(handler, { target: e.target, intersections });
            }
          }
        }
      });
    },
    [hoverState, interactions]
  );
  useXREvent("select", triggerEvent("onSelect"));
  useXREvent("selectstart", triggerEvent("onSelectStart"));
  useXREvent("selectend", triggerEvent("onSelectEnd"));
  useXREvent("squeeze", triggerEvent("onSqueeze"));
  useXREvent("squeezeend", triggerEvent("onSqueezeEnd"));
  useXREvent("squeezestart", triggerEvent("onSqueezeStart"));
  return React2.createElement(React2.Fragment, null, children);
}
function useInteraction(ref, type, handler) {
  const addInteraction = useXR((state) => state.addInteraction);
  const removeInteraction = useXR((state) => state.removeInteraction);
  const handlerRef = useCallbackRef(handler);
  useIsomorphicLayoutEffect(() => {
    const target = ref.current;
    if (!target || !handlerRef.current)
      return;
    addInteraction(target, type, handlerRef);
    return () => removeInteraction(target, type, handlerRef);
  }, [ref, type, addInteraction, removeInteraction]);
}
var Interactive = React2.forwardRef(function Interactive2({
  onHover,
  onBlur,
  onSelectStart,
  onSelectEnd,
  onSelectMissed,
  onSelect,
  onSqueezeStart,
  onSqueezeEnd,
  onSqueezeMissed,
  onSqueeze,
  onMove,
  children
}, passedRef) {
  const ref = React2.useRef(null);
  React2.useImperativeHandle(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelectMissed", onSelectMissed);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueezeMissed", onSqueezeMissed);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return React2.createElement("group", {
    ref
  }, children);
});
var RayGrab = React2.forwardRef(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = React2.useRef();
  const groupRef = React2.useRef(null);
  const previousTransform = React2.useMemo(() => new Matrix4(), []);
  React2.useImperativeHandle(forwardedRef, () => groupRef.current);
  useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!controller)
      return;
    group.applyMatrix4(previousTransform);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return React2.createElement(Interactive, {
    ref: groupRef,
    onSelectStart: (e) => {
      grabbingController.current = e.target.controller;
      previousTransform.copy(e.target.controller.matrixWorld).invert();
      onSelectStart == null ? void 0 : onSelectStart(e);
    },
    onSelectEnd: (e) => {
      if (e.target.controller === grabbingController.current) {
        grabbingController.current = void 0;
      }
      onSelectEnd == null ? void 0 : onSelectEnd(e);
    },
    ...rest
  }, children);
});
function useHitTest(hitTestCallback) {
  const session = useXR((state) => state.session);
  const hitTestSource = React2.useRef();
  const hitMatrix = React2.useMemo(() => new Matrix4(), []);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void (hitTestSource.current = void 0);
    session.requestReferenceSpace("viewer").then(async (referenceSpace) => {
      var _a2;
      hitTestSource.current = await ((_a2 = session == null ? void 0 : session.requestHitTestSource) == null ? void 0 : _a2.call(session, { space: referenceSpace }));
    });
  }, [session]);
  useFrame((state, _, frame) => {
    if (!frame || !hitTestSource.current)
      return;
    const [hit] = frame.getHitTestResults(hitTestSource.current);
    if (hit) {
      const referenceSpace = state.gl.xr.getReferenceSpace();
      const pose = hit.getPose(referenceSpace);
      if (pose) {
        hitMatrix.fromArray(pose.transform.matrix);
        hitTestCallback(hitMatrix, hit);
      }
    }
  });
}

// node_modules/@react-three/xr/dist/context.js
var React3 = __toESM(require_react(), 1);
var XRContext = React3.createContext(null);

// node_modules/@react-three/xr/dist/XR.js
var globalSessionStore = create((set, get) => ({ set, get, session: null, referenceSpaceType: null }));
function XRManager({
  foveation = 0,
  frameRate = void 0,
  referenceSpace = "local-floor",
  onSessionStart,
  onSessionEnd,
  onVisibilityChange,
  onInputSourcesChange,
  children
}) {
  const gl = useThree((state) => state.gl);
  const camera = useThree((state) => state.camera);
  const player = useXR((state) => state.player);
  const get = useXR((state) => state.get);
  const set = useXR((state) => state.set);
  const session = useXR((state) => state.session);
  const controllers = useXR((state) => state.controllers);
  const onSessionStartRef = useCallbackRef(onSessionStart);
  const onSessionEndRef = useCallbackRef(onSessionEnd);
  const onVisibilityChangeRef = useCallbackRef(onVisibilityChange);
  const onInputSourcesChangeRef = useCallbackRef(onInputSourcesChange);
  useIsomorphicLayoutEffect(() => {
    const handlers = [0, 1].map((id) => {
      const target = new XRController(id, gl);
      const onConnected = () => set((state) => ({ controllers: [...state.controllers, target] }));
      const onDisconnected = () => set((state) => ({ controllers: state.controllers.filter((it) => it !== target) }));
      target.addEventListener("connected", onConnected);
      target.addEventListener("disconnected", onDisconnected);
      return () => {
        target.removeEventListener("connected", onConnected);
        target.removeEventListener("disconnected", onDisconnected);
      };
    });
    return () => handlers.forEach((cleanup) => cleanup());
  }, [gl, set]);
  useIsomorphicLayoutEffect(() => globalSessionStore.subscribe(({ session: session2 }) => set(() => ({ session: session2 }))), [gl.xr, set]);
  useIsomorphicLayoutEffect(() => {
    gl.xr.setFoveation(foveation);
    set(() => ({ foveation }));
  }, [gl.xr, foveation, set]);
  useIsomorphicLayoutEffect(() => {
    var _a2;
    try {
      if (frameRate)
        (_a2 = session == null ? void 0 : session.updateTargetFrameRate) == null ? void 0 : _a2.call(session, frameRate);
    } catch (_) {
    }
    set(() => ({ frameRate }));
  }, [session, frameRate, set]);
  useIsomorphicLayoutEffect(() => {
    const globalSessionState = globalSessionStore.getState();
    gl.xr.setReferenceSpaceType(referenceSpace);
    set(() => ({ referenceSpace }));
    globalSessionState.set({ referenceSpaceType: referenceSpace });
  }, [gl.xr, referenceSpace, set]);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void gl.xr.setSession(null);
    const handleSessionStart = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: true }));
      (_a2 = onSessionStartRef.current) == null ? void 0 : _a2.call(onSessionStartRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleSessionEnd = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: false, session: null }));
      globalSessionStore.setState(() => ({ session: null }));
      (_a2 = onSessionEndRef.current) == null ? void 0 : _a2.call(onSessionEndRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleVisibilityChange = (nativeEvent) => {
      var _a2;
      (_a2 = onVisibilityChangeRef.current) == null ? void 0 : _a2.call(onVisibilityChangeRef, { nativeEvent, target: session });
    };
    const handleInputSourcesChange = (nativeEvent) => {
      var _a2;
      const isHandTracking = Object.values(session.inputSources).some((source) => source.hand);
      set(() => ({ isHandTracking }));
      (_a2 = onInputSourcesChangeRef.current) == null ? void 0 : _a2.call(onInputSourcesChangeRef, { nativeEvent, target: session });
    };
    gl.xr.addEventListener("sessionstart", handleSessionStart);
    gl.xr.addEventListener("sessionend", handleSessionEnd);
    session.addEventListener("visibilitychange", handleVisibilityChange);
    session.addEventListener("inputsourceschange", handleInputSourcesChange);
    gl.xr.setSession(session).then(() => {
      gl.xr.setFoveation(get().foveation);
    });
    return () => {
      gl.xr.removeEventListener("sessionstart", handleSessionStart);
      gl.xr.removeEventListener("sessionend", handleSessionEnd);
      session.removeEventListener("visibilitychange", handleVisibilityChange);
      session.removeEventListener("inputsourceschange", handleInputSourcesChange);
    };
  }, [session, gl.xr, set, get]);
  return React4.createElement(InteractionManager, null, React4.createElement("primitive", {
    object: player
  }, React4.createElement("primitive", {
    object: camera
  }), controllers.map((controller) => React4.createElement("primitive", {
    key: controller.index,
    object: controller
  }))), children);
}
function XR(props) {
  const store = React4.useMemo(
    () => create((set, get) => ({
      set,
      get,
      controllers: [],
      isPresenting: false,
      isHandTracking: false,
      player: new Group(),
      session: null,
      foveation: 0,
      referenceSpace: "local-floor",
      hoverState: {
        left: /* @__PURE__ */ new Map(),
        right: /* @__PURE__ */ new Map(),
        none: /* @__PURE__ */ new Map()
      },
      interactions: /* @__PURE__ */ new Map(),
      hasInteraction(object, eventType) {
        var _a2;
        return !!((_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].some((handlerRef) => handlerRef.current));
      },
      getInteraction(object, eventType) {
        var _a2;
        return (_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].reduce((result, handlerRef) => {
          if (handlerRef.current) {
            result.push(handlerRef.current);
          }
          return result;
        }, []);
      },
      addInteraction(object, eventType, handlerRef) {
        const interactions = get().interactions;
        if (!interactions.has(object)) {
          interactions.set(object, {
            onHover: [],
            onBlur: [],
            onSelect: [],
            onSelectEnd: [],
            onSelectStart: [],
            onSelectMissed: [],
            onSqueeze: [],
            onSqueezeEnd: [],
            onSqueezeStart: [],
            onSqueezeMissed: [],
            onMove: []
          });
        }
        const target = interactions.get(object);
        target[eventType].push(handlerRef);
      },
      removeInteraction(object, eventType, handlerRef) {
        const target = get().interactions.get(object);
        if (target) {
          const interactionIndex = target[eventType].indexOf(handlerRef);
          if (interactionIndex !== -1)
            target[eventType].splice(interactionIndex, 1);
        }
      }
    })),
    []
  );
  return React4.createElement(XRContext.Provider, {
    value: store
  }, React4.createElement(XRManager, {
    ...props
  }));
}
var getSessionOptions = (globalStateReferenceSpaceType, sessionInit) => {
  var _a2;
  if (!globalStateReferenceSpaceType && !sessionInit) {
    return void 0;
  }
  if (globalStateReferenceSpaceType && !sessionInit) {
    return { optionalFeatures: [globalStateReferenceSpaceType] };
  }
  if (globalStateReferenceSpaceType && sessionInit) {
    return { ...sessionInit, optionalFeatures: uniq([...(_a2 = sessionInit.optionalFeatures) != null ? _a2 : [], globalStateReferenceSpaceType]) };
  }
  return sessionInit;
};
var startSession = async (sessionMode, sessionInit) => {
  const xrState = globalSessionStore.getState();
  if (xrState.session) {
    console.warn("@react-three/xr: session already started, please stop it first");
    return;
  }
  const options = getSessionOptions(xrState.referenceSpaceType, sessionInit);
  const session = await navigator.xr.requestSession(sessionMode, options);
  xrState.set(() => ({ session }));
  return session;
};
var stopSession = async () => {
  const xrState = globalSessionStore.getState();
  if (!xrState.session) {
    console.warn("@react-three/xr: no session to stop, please start it first");
    return;
  }
  await xrState.session.end();
  xrState.set({ session: null });
};
var toggleSession = async (sessionMode, { sessionInit, enterOnly, exitOnly } = {}) => {
  const xrState = globalSessionStore.getState();
  if (xrState.session && enterOnly)
    return;
  if (!xrState.session && exitOnly)
    return;
  if (xrState.session) {
    return await stopSession();
  } else {
    return await startSession(sessionMode, sessionInit);
  }
};
var getLabel = (status, mode, reason) => {
  switch (status) {
    case "entered":
      return `Exit ${mode}`;
    case "exited":
      return `Enter ${mode}`;
    case "unsupported":
    default:
      switch (reason) {
        case "https":
          return "HTTPS needed";
        case "security":
          return `${mode} blocked`;
        case "unknown":
        default:
          return `${mode} unsupported`;
      }
  }
};
var XRButton = React4.forwardRef(function XRButton2({ mode, sessionInit, enterOnly = false, exitOnly = false, onClick, onError, children, ...props }, ref) {
  var _a2;
  const [status, setStatus] = React4.useState("exited");
  const [reason, setReason] = React4.useState("unknown");
  const label = getLabel(status, mode, reason);
  const sessionMode = mode === "inline" ? mode : `immersive-${mode.toLowerCase()}`;
  const onErrorRef = useCallbackRef(onError);
  useIsomorphicLayoutEffect(() => {
    if (!(navigator == null ? void 0 : navigator.xr))
      return void setStatus("unsupported");
    navigator.xr.isSessionSupported(sessionMode).then((supported) => {
      if (!supported) {
        const isHttps = location.protocol === "https:";
        setStatus("unsupported");
        setReason(isHttps ? "unknown" : "https");
      } else {
        setStatus("exited");
      }
    }).catch((error) => {
      setStatus("unsupported");
      if ("name" in error && error.name === "SecurityError") {
        setReason("security");
      } else {
        setReason("unknown");
      }
    });
  }, [sessionMode]);
  useIsomorphicLayoutEffect(
    () => globalSessionStore.subscribe((state) => {
      if (state.session) {
        setStatus("entered");
      } else if (status !== "unsupported") {
        setStatus("exited");
      }
    }),
    [status]
  );
  const handleButtonClick = React4.useCallback(
    async (event) => {
      onClick == null ? void 0 : onClick(event);
      try {
        toggleSession(sessionMode, { sessionInit, enterOnly, exitOnly });
      } catch (e) {
        const onError2 = onErrorRef.current;
        if (onError2 && e instanceof Error)
          onError2(e);
        else
          throw e;
      }
    },
    [onClick, sessionMode, sessionInit, enterOnly, exitOnly, onErrorRef]
  );
  return React4.createElement("button", {
    ...props,
    ref,
    onClick: status === "unsupported" ? onClick : handleButtonClick
  }, (_a2 = typeof children === "function" ? children(status) : children) != null ? _a2 : label);
});
var buttonStyles = {
  position: "absolute",
  bottom: "24px",
  left: "50%",
  transform: "translateX(-50%)",
  padding: "12px 24px",
  border: "1px solid white",
  borderRadius: "4px",
  background: "rgba(0, 0, 0, 0.1)",
  color: "white",
  font: "normal 0.8125rem sans-serif",
  outline: "none",
  zIndex: 99999,
  cursor: "pointer"
};
var ARButton = React4.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = {
      domOverlay: typeof document !== "undefined" ? { root: document.body } : void 0,
      optionalFeatures: ["hit-test", "dom-overlay", "dom-overlay-for-handheld-ar"]
    },
    children,
    ...rest
  }, ref) => React4.createElement(XRButton, {
    ...rest,
    ref,
    mode: "AR",
    style,
    sessionInit
  }, children)
);
var VRButton = React4.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] },
    children,
    ...rest
  }, ref) => React4.createElement(XRButton, {
    ...rest,
    ref,
    mode: "VR",
    style,
    sessionInit
  }, children)
);
function useXR(selector = (state) => state, equalityFn) {
  const store = React4.useContext(XRContext);
  if (!store)
    throw new Error("useXR must be used within an <XR /> component!");
  return store(selector, equalityFn);
}
function useController(handedness) {
  const controllers = useXR((state) => state.controllers);
  const controller = React4.useMemo(
    () => controllers.find(({ inputSource }) => (inputSource == null ? void 0 : inputSource.handedness) && inputSource.handedness === handedness),
    [handedness, controllers]
  );
  return controller;
}

// node_modules/@react-three/xr/dist/XRControllerModelFactory.js
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var XRControllerModelFactory = class {
  constructor(gltfLoader = null, path = DEFAULT_PROFILES_PATH) {
    this.gltfLoader = gltfLoader != null ? gltfLoader : new GLTFLoader();
    this.path = path;
    this._assetCache = {};
  }
  initializeControllerModel(controllerModel, xrInputSource) {
    if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad) {
      return Promise.resolve();
    }
    return fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {
      if (!assetPath) {
        throw new Error("no asset path");
      }
      const motionController = new MotionController(xrInputSource, profile, assetPath);
      controllerModel.connectMotionController(motionController);
      const assetUrl = motionController.assetUrl;
      const cachedAsset = this._assetCache[assetUrl];
      if (cachedAsset) {
        const scene = cachedAsset.scene.clone();
        controllerModel.connectModel(scene);
      } else {
        if (!this.gltfLoader) {
          throw new Error("GLTFLoader not set.");
        }
        this.gltfLoader.setPath("");
        this.gltfLoader.load(
          assetUrl,
          (asset) => {
            if (!controllerModel.motionController) {
              console.warn("motionController gone while gltf load, bailing...");
              return;
            }
            this._assetCache[assetUrl] = asset;
            const scene = asset.scene.clone();
            controllerModel.connectModel(scene);
          },
          void 0,
          () => {
            throw new Error(`Asset ${assetUrl} missing or malformed.`);
          }
        );
      }
    }).catch((err) => {
      console.warn(err);
    });
  }
};

// node_modules/@react-three/xr/dist/XRControllerModel.js
var isEnvMapApplicable = (material) => "envMap" in material;
var updateEnvMap = (material, envMap) => {
  material.envMap = envMap;
  material.needsUpdate = true;
};
var applyEnvironmentMap = (envMap, obj) => {
  if (obj instanceof Mesh) {
    if (Array.isArray(obj.material)) {
      obj.material.forEach((m) => isEnvMapApplicable(m) ? updateEnvMap(m, envMap) : void 0);
    } else if (isEnvMapApplicable(obj.material)) {
      updateEnvMap(obj.material, envMap);
    }
  }
};
var isEnvMapIntensityApplicable = (material) => "envMapIntensity" in material;
var updateEnvMapIntensity = (material, envMapIntensity) => {
  material.envMapIntensity = envMapIntensity;
  material.needsUpdate = true;
};
var applyEnvironmentMapIntensity = (envMapIntensity, obj) => {
  if (obj instanceof Mesh) {
    if (Array.isArray(obj.material)) {
      obj.material.forEach((m) => isEnvMapIntensityApplicable(m) ? updateEnvMapIntensity(m, envMapIntensity) : void 0);
    } else if (isEnvMapIntensityApplicable(obj.material)) {
      updateEnvMapIntensity(obj.material, envMapIntensity);
    }
  }
};
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const { type, touchPointNodeName, visualResponses } = component;
    if (type === MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new SphereGeometry(1e-3);
        const material = new MeshBasicMaterial({ color: 255 });
        const sphere = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap || controllerModel.envMapIntensity != null) {
    scene.traverse((c) => {
      if (controllerModel.envMap)
        applyEnvironmentMap(controllerModel.envMap, c);
      if (controllerModel.envMapIntensity != null)
        applyEnvironmentMapIntensity(controllerModel.envMapIntensity, c);
    });
  }
  controllerModel.add(scene);
}
var XRControllerModel = class extends Group {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.scene = null;
  }
  setEnvironmentMap(envMap, envMapIntensity = 1) {
    var _a2;
    if (this.envMap === envMap && this.envMapIntensity === envMapIntensity) {
      return this;
    }
    this.envMap = envMap;
    this.envMapIntensity = envMapIntensity;
    (_a2 = this.scene) == null ? void 0 : _a2.traverse((c) => {
      applyEnvironmentMap(envMap, c);
      applyEnvironmentMapIntensity(envMapIntensity, c);
    });
    return this;
  }
  setEnvironmentMapIntensity(envMapIntensity) {
    var _a2;
    if (this.envMapIntensity === envMapIntensity) {
      return this;
    }
    this.envMapIntensity = envMapIntensity;
    (_a2 = this.scene) == null ? void 0 : _a2.traverse((c) => applyEnvironmentMapIntensity(envMapIntensity, c));
    return this;
  }
  connectModel(scene) {
    if (!this.motionController) {
      console.warn("scene tried to add, but no motion controller");
      return;
    }
    this.scene = scene;
    addAssetSceneToControllerModel(this, scene);
    this.dispatchEvent({
      type: "modelconnected",
      data: scene
    });
  }
  connectMotionController(motionController) {
    this.motionController = motionController;
    this.dispatchEvent({
      type: "motionconnected",
      data: motionController
    });
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;
        if (!valueNode)
          return;
        if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === "boolean") {
          valueNode.visible = value;
        } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === "number") {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
  disconnect() {
    this.dispatchEvent({
      type: "motiondisconnected",
      data: this.motionController
    });
    this.dispatchEvent({
      type: "modeldisconnected",
      data: this.scene
    });
    this.motionController = null;
    if (this.scene) {
      this.remove(this.scene);
    }
    this.scene = null;
  }
  dispose() {
    this.disconnect();
  }
};

// node_modules/@react-three/xr/dist/Controllers.js
var Ray = React5.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState);
  const ray = React5.useRef(null);
  const rayGeometry = React5.useMemo(
    () => new BufferGeometry().setFromPoints([new Vector3(0, 0, 0), new Vector3(0, 0, -1)]),
    []
  );
  React5.useImperativeHandle(forwardedRef, () => ray.current);
  useFrame(() => {
    if (!target.inputSource) {
      return;
    }
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return React5.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
var modelFactory = new XRControllerModelFactory();
var ControllerModel = ({
  target,
  envMap,
  envMapIntensity
}) => {
  const xrControllerModelRef = React5.useRef(null);
  const setEnvironmentMapRef = useCallbackRef((xrControllerModel) => {
    if (envMap == null)
      return;
    xrControllerModel.setEnvironmentMap(envMap);
  });
  const clearEnvironmentMapRef = useCallbackRef((xrControllerModel) => xrControllerModel.setEnvironmentMap(null));
  const setEnvironmentMapIntensityRef = useCallbackRef((xrControllerModel) => {
    if (envMapIntensity == null)
      return;
    xrControllerModel.setEnvironmentMapIntensity(envMapIntensity);
  });
  const handleControllerModel = React5.useCallback(
    (xrControllerModel) => {
      var _a2, _b2, _c;
      xrControllerModelRef.current = xrControllerModel;
      if (xrControllerModel) {
        target.xrControllerModel = xrControllerModel;
        if ((_a2 = target.inputSource) == null ? void 0 : _a2.hand) {
          return;
        }
        setEnvironmentMapRef.current(xrControllerModel);
        setEnvironmentMapIntensityRef.current(xrControllerModel);
        if (target.inputSource) {
          modelFactory.initializeControllerModel(xrControllerModel, target.inputSource);
        } else {
          console.warn("no input source on XRController when handleControllerModel");
        }
      } else {
        if ((_b2 = target.inputSource) == null ? void 0 : _b2.hand) {
          return;
        }
        (_c = target.xrControllerModel) == null ? void 0 : _c.disconnect();
        target.xrControllerModel = null;
      }
    },
    [target, setEnvironmentMapIntensityRef, setEnvironmentMapRef]
  );
  React5.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      if (envMap) {
        setEnvironmentMapRef.current(xrControllerModelRef.current);
      } else {
        clearEnvironmentMapRef.current(xrControllerModelRef.current);
      }
    }
  }, [envMap, setEnvironmentMapRef, clearEnvironmentMapRef]);
  React5.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      setEnvironmentMapIntensityRef.current(xrControllerModelRef.current);
    }
  }, [envMapIntensity, setEnvironmentMapIntensityRef]);
  return React5.createElement("xRControllerModel", {
    ref: handleControllerModel
  });
};
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false, envMap, envMapIntensity }) {
  const controllers = useXR((state) => state.controllers);
  const isHandTracking = useXR((state) => state.isHandTracking);
  const rayMaterialProps = React5.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React5.useMemo(() => extend({ XRControllerModel }), []);
  return React5.createElement(React5.Fragment, null, controllers.map((target, i) => React5.createElement(React5.Fragment, {
    key: i
  }, createPortal(React5.createElement(ControllerModel, {
    target,
    envMap,
    envMapIntensity
  }), target.grip), createPortal(
    React5.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}

// node_modules/@react-three/xr/dist/Hands.js
var React6 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XRHandMeshModel.js
var DEFAULT_HAND_PROFILE_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
var XRHandMeshModel = class {
  constructor(handModel, controller, path = DEFAULT_HAND_PROFILE_PATH, handedness, customModelPath) {
    this.controller = controller;
    this.handModel = handModel;
    this.bones = [];
    const loader = new GLTFLoader();
    if (!customModelPath)
      loader.setPath(path);
    loader.load(customModelPath != null ? customModelPath : `${handedness}.glb`, (gltf) => {
      const object = gltf.scene.children[0];
      this.handModel.add(object);
      this.scene = object;
      const mesh = object.getObjectByProperty("type", "SkinnedMesh");
      mesh.frustumCulled = false;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      const joints = [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ];
      joints.forEach((jointName) => {
        const bone = object.getObjectByName(jointName);
        if (bone !== void 0) {
          bone.jointName = jointName;
        } else {
          console.warn(`Couldn't find ${jointName} in ${handedness} hand mesh`);
        }
        this.bones.push(bone);
      });
    });
  }
  updateMesh() {
    const XRJoints = this.controller.joints;
    let allInvisible = true;
    for (let i = 0; i < this.bones.length; i++) {
      const bone = this.bones[i];
      if (bone) {
        const XRJoint = XRJoints[bone.jointName];
        if (XRJoint.visible) {
          const position = XRJoint.position;
          bone.position.copy(position);
          bone.quaternion.copy(XRJoint.quaternion);
          allInvisible = false;
        }
      }
    }
    if (allInvisible && this.scene) {
      this.scene.visible = false;
    } else if (this.scene) {
      this.scene.visible = true;
    }
  }
  dispose() {
    if (this.scene) {
      this.handModel.remove(this.scene);
    }
  }
};

// node_modules/@react-three/xr/dist/OculusHandModel.js
var TOUCH_RADIUS = 0.01;
var POINTING_JOINT = "index-finger-tip";
var OculusHandModel = class extends Object3D {
  constructor(controller, leftModelPath, rightModelPath) {
    super();
    this._onConnected = (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.hand && !this.motionController) {
        this.xrInputSource = xrInputSource;
        this.motionController = new XRHandMeshModel(
          this,
          this.controller,
          void 0,
          xrInputSource.handedness,
          xrInputSource.handedness === "left" ? this.leftModelPath : this.rightModelPath
        );
      }
    };
    this._onDisconnected = () => {
      var _a2;
      if (!((_a2 = this.xrInputSource) == null ? void 0 : _a2.hand)) {
        return;
      }
      this.motionControllerCleanup();
    };
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.leftModelPath = leftModelPath;
    this.rightModelPath = rightModelPath;
    this.mesh = null;
    this.xrInputSource = null;
    controller.addEventListener("connected", this._onConnected);
    controller.addEventListener("disconnected", this._onDisconnected);
  }
  motionControllerCleanup() {
    var _a2;
    this.clear();
    (_a2 = this.motionController) == null ? void 0 : _a2.dispose();
    this.motionController = null;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }
  getPointerPosition() {
    const indexFingerTip = this.controller.joints[POINTING_JOINT];
    if (indexFingerTip) {
      return indexFingerTip.position;
    } else {
      return null;
    }
  }
  intersectBoxObject(boxObject) {
    const pointerPosition = this.getPointerPosition();
    if (pointerPosition) {
      const indexSphere = new Sphere(pointerPosition, TOUCH_RADIUS);
      const box = new Box3().setFromObject(boxObject);
      return indexSphere.intersectsBox(box);
    } else {
      return false;
    }
  }
  checkButton(button) {
    if (this.intersectBoxObject(button)) {
      button.onPress();
    } else {
      button.onClear();
    }
    if (button.isPressed()) {
      button.whilePressed();
    }
  }
  dispose() {
    this.motionControllerCleanup();
    this.controller.removeEventListener("connected", this._onConnected);
    this.controller.removeEventListener("disconnected", this._onDisconnected);
  }
};

// node_modules/@react-three/xr/dist/Hands.js
function Hands({ modelLeft, modelRight }) {
  const controllers = useXR((state) => state.controllers);
  React6.useMemo(() => extend({ OculusHandModel }), []);
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.hand.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers, modelLeft, modelRight]);
  return React6.createElement(React6.Fragment, null, controllers.map(({ hand }) => createPortal(React6.createElement("oculusHandModel", {
    args: [hand, modelLeft, modelRight]
  }), hand)));
}

// node_modules/@react-three/xr/dist/Teleportation.js
var React7 = __toESM(require_react(), 1);
var _q = new Quaternion();
function useTeleportation() {
  const frame = React7.useRef();
  const baseReferenceSpace = React7.useRef(null);
  const teleportReferenceSpace = React7.useRef(null);
  useFrame((state, _, xrFrame) => {
    var _a2;
    frame.current = xrFrame;
    const referenceSpace = state.gl.xr.getReferenceSpace();
    (_a2 = baseReferenceSpace.current) != null ? _a2 : baseReferenceSpace.current = referenceSpace;
    const teleportOffset = teleportReferenceSpace.current;
    if (teleportOffset && referenceSpace !== teleportOffset) {
      state.gl.xr.setReferenceSpace(teleportOffset);
    }
  });
  return React7.useCallback((target) => {
    var _a2;
    const base = baseReferenceSpace.current;
    if (base) {
      const [x, y, z] = Array.from(target);
      const offsetFromBase = { x: -x, y: -y, z: -z };
      const pose = (_a2 = frame.current) == null ? void 0 : _a2.getViewerPose(base);
      if (pose) {
        offsetFromBase.x += pose.transform.position.x;
        offsetFromBase.z += pose.transform.position.z;
      }
      const teleportOffset = new XRRigidTransform(offsetFromBase, _q);
      teleportReferenceSpace.current = base.getOffsetReferenceSpace(teleportOffset);
    }
  }, []);
}
var TeleportationPlane = React7.forwardRef(function TeleportationPlane2({ leftHand = false, rightHand = false, maxDistance = 10, size = 0.25, ...props }, ref) {
  const teleport = useTeleportation();
  const marker = React7.useRef(null);
  const intersection = React7.useRef();
  const camera = useThree((state) => state.camera);
  const isInteractive = React7.useCallback(
    (e) => {
      var _a2;
      const handedness = (_a2 = e.target.inputSource) == null ? void 0 : _a2.handedness;
      return !!((handedness !== "left" || leftHand) && (handedness !== "right" || rightHand));
    },
    [leftHand, rightHand]
  );
  return React7.createElement("group", {
    ref,
    ...props
  }, React7.createElement("mesh", {
    ref: marker,
    visible: false,
    "rotation-x": -Math.PI / 2
  }, React7.createElement("circleGeometry", {
    args: [size, 32]
  }), React7.createElement("meshBasicMaterial", {
    color: "white"
  })), React7.createElement(Interactive, {
    onMove: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
      intersection.current = e.intersection.point;
      marker.current.position.copy(intersection.current);
    },
    onHover: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1);
    },
    onBlur: (e) => {
      if (!isInteractive(e))
        return;
      marker.current.visible = false;
    },
    onSelectStart: (e) => {
      if (!isInteractive(e) || !e.intersection)
        return;
      const distanceFromCamera = e.intersection.point.distanceTo(camera.position);
      marker.current.visible = distanceFromCamera <= maxDistance;
      marker.current.scale.setScalar(1.1);
    },
    onSelectEnd: (e) => {
      if (!isInteractive(e) || !intersection.current)
        return;
      marker.current.visible = true;
      marker.current.scale.setScalar(1);
      const distanceFromCamera = intersection.current.distanceTo(camera.position);
      if (distanceFromCamera <= maxDistance) {
        teleport(intersection.current);
      }
    }
  }, React7.createElement("mesh", {
    "rotation-x": -Math.PI / 2,
    visible: false,
    scale: 1e3
  }, React7.createElement("planeGeometry", null))));
});
export {
  ARButton,
  Controllers,
  Hands,
  InteractionManager,
  Interactive,
  Ray,
  RayGrab,
  TeleportationPlane,
  VRButton,
  XR,
  XRButton,
  XRController,
  XRControllerModelFactory,
  startSession,
  stopSession,
  toggleSession,
  useController,
  useHitTest,
  useInteraction,
  useTeleportation,
  useXR,
  useXREvent
};
//# sourceMappingURL=@react-three_xr.js.map
